

http://www.pab-sh.cn/AFIS3/
https://uat.dulux-easypaint.com/login
https://www.dulux-easypaint.com/login
https://cm.dulux.com.cn/login.jsp
如今我又来到人生的十岔口，我知道，毫无例外，我都知道，哪条是正途。可我从来都不走，为什么？因为太他妈辛苦了！
有的鸟儿是注定关不住的，因为他们的羽毛太过锋芒！

深入JVM虚拟机

	集合、IO流、异常、多线程(同步-并发)
	SpringMVC、拦截器、过滤器、定时任务、Log4j
	html、css、JavaScript、ajax、json、JQuery、Bootstrap
	Mybatis、SQL
	AOP、IOC、事务
	jvm、GC、反射机制
	git、Maven、tomcat
	java8
	其它：数据源技术
	
	
	
	Object常用方法：
		equals,hashcode,toString,getClass,wait,notify,notifyAll,clone
	自动拆装箱：
		将基础类型与包装类的转换
	网络协议：
		HTTP：超文本传输协议
		FTP：文件传输协议
		SMPT：简单邮件协议
		TELNET：远程终端协议
		POP3：邮件读取协议
	Java常用包:
		Java.lang
		Java.io
		Java.sql
		Java.util
		Java.awt
		Java.net
		Java.math
	线程池
		线程池的实现原理，这个知识点真的很重要，几乎每次面试都会被问到，一般的提问方式有如下几种
	锁的实现
		在关于锁的面试过程中，一般主要问Synchronized和ReentrantLock的实现原理，更有甚者会问读写锁
	java 8红黑树的概念


	
IO流
	InputStream
		FileInputStream
		BufferedInputStream
	OutputStream
		FileOutputStream
		BufferedOutputStream
	
	Reader
		InputStreamReader
			FileReader
		BufferedReader
	Writer
		OutputStreamWriter
			FileWriter
		BufferedWriter

	做过的项目
		Trading， 平安汽融
	自己定义拦截器
		实现接口,另外一种是继承适配器类 HandlerInterceptorAdapter
	SpringMvc处理返回值
		配置文件中InternalResourceViewResolver的前缀和后缀
	当一个方法向AJAX返回特殊对象
		加上@ResponseBody注解
	并发、并行区别
		并发：多个线程被一个CPU执行
		并行：多个线程被多个CPU执行
	分布、集群
		分布：一个业务拆分成若干个子业务，部署在不同的服务器上
		集群：同一个业务部署在多个服务器上
	网站高并发性能优化
		硬件：增加带宽，宽容CPU、扩容内存，
		软件：合理合并js文件以减少IO读取次数，数据库读取上选用radis缓存
	定时任务Quertz
		quartz.SchedulerFactoryBean
	数据库连接池
		dbcp.BasicDataSource
	数据库事物
		transactionManager
	Mybatis配置
		SqlSessionFactoryBean
	Trading邮件发送
	IOC
		传统我们通过new来创建一个对象，现在由spring容器帮我们依赖注入对象，即由原先的人为控制转为容器控制。
	AOP
		优点自然还是提高效率，AOP将业务逻辑各部分进行划分隔离，提高程序可重用性。例如通过AOP可将日志、事物等从业务逻辑层抽取出来(省去传统的繁琐)
	进程和线程
		进程：是系统分配和管理资源的基本单位，它包含若干个线程
		线程：是进程的组成部分
	序列化和反序列化
		1，通过实现接口Serializable来序列化，使用ObjectInputStream 实现反序列化；
		2，序列化是将java对象和一串二进制字节流之间做转换，java对象只存在jvm中，当程序退出时，这些对象也就消失，而序列化则是将这些对象保存到磁盘
		       中，以备使用。
	反射机制
		定义：指程序在运行时可检测、修改或调整自身状态或行为的一种能力，在java中，只要给出类的名称，便可以访问类的所有属性；
		作用：
			(1)在运行时可检测任意对象所属的类；
			(2)在运行时访问类的对象；
			(3)在运行时访问对象的所有属性、方法、构造方法。
		引出两个编译概念
			静态编译：在编译时确定类型，绑定对象
			动态编译：在运行时确定类型，绑定对象
		优点：可以动态创建对象和编译，提高代码灵活性
		有点举例：一个大型项目，程序编译且发布后，需要更新某新功能，此时不可能卸载老版本，重新装新版本。可采用反射机制动态创建和编译。
		缺点：使用反射机制是一种解释操作，让jvm按照要求操作，这比直接执行相同的操作要慢，故影响性能
		
	springMVC启动流程
		简单分为两个初始化
		1，监听器ContextLoaderListener的初始化，它实现了接口ServletContextListener，当服务器启动时，调用其ContextIniti..方
		       法，自动装配ApplicationContext配置信息，并完成载入和初始化过程，此初始化的第一个上下文即为根上下文，它将绑定到web程序中的
		  ServletContext中，为后续的IOC容器提供宿主。IOC容器是通过调用refleash方法载入的，该方法主要完成以下3件事：
		   (1)定位Resource文件路径，找到bean配置文件；
		   (2)通过特殊的reader解析bean配置文件，抽象成beanDefinition类
		   (3)将beanDefinition向容器注册，保存在HashMap中，供后续使用
		2，DispatcherServlet的初始化，首先它是一个Servlet，是HttpServlet的子类，当web程序启动时，调用其init方法，进行初始化，
		  DispatcherServlet在建立自己的(持有IOC容器的)上下文前，先获得根上下文，初始化过程大概是初始化处理器映射器、视图解析器等。完成初始化
		      后，将之保存到ServletContext中，供后续使用。
		  --另外，IOC中的若干个Servlet都有自己独立的bean空间
	springMVC工作流程
		1，用户发出url访问请求到中央控制器DispatcherServlet
		2，中央控制器找到处理器映射器HandlerMapper
		3，处理器映射器根据url信息返回相应处理器适配器地址信息给中央控制器(如果有处理器拦截器，则一并生成)
		5，中央控制器找到处理器适配器HandlerAdapter
		6，处理器适配器经过数据转化、格式化等转交给Handler，即Controller
		7，Handler处理相关业务，返回ModelAndView给处理器适配器
		8，处理器适配器将结果返回给中央控制器
		9，中央控制器再找到视图解析器ViewReslover
		10，viewReslover解析后返回具体View到中央控制器
		10，中央控制器将view渲染响应给用户

	GC面试：GC在什么时候，对什么东西，做了什么事情？
		1，minor gc：eden满了；full gc：升到老年代的对象大于老年代剩余空间等
		2，GC roots不可达的对象，即对象到GC roots没有任何引用链链接；可做GC roots的对象有：
			(1)虚拟机栈（栈帧中的本地变量表）中的引用的对象
			(2)方法区中的类静态属性引用的对象
			(3)方法区中的常量引用的对象
			(4)本地方法栈中JNI（Native方法）的引用对象
		3，回收算法
			(1)复制算法进行垃圾回收... 新生代(Eden Survivor1 Survivor2)		老年代
				缺点：复制算法中老年代中的对象存活交久，故复制的成本交高；
			(2)标记整理算法，又叫标记压缩算法，是对老年代的回收。先标记GC roots可达对象，并将这些对象压缩到内存的一端，再对其它区域清理回收
		4，引申垃圾回收器
			(1)CMS收集器，收集范围是老年代，基于标记-清除算法，故易产生大量空间碎片，分配大对象时不得不full GC。
			         四个步骤：
				初始标记(initial mark)			快，stop the world
				并发标记(concurrent mark)		快，stop the world
				重新标记(remark)				慢，但可以和用户进程同时工作
				并发清除(concurrent sweep)		慢，但可以和用户进程同时工作
			(2)G1收集器，JDK1.7提供的，收集范围是java堆(包括新生代、老年代)，基于标记-整理算法，所以没有碎片

	OSI
		应用层	Boss		用户
		表示层	秘书			解析、加密、翻译等
		会话层	外联部管理		负责地址信息和联系方式
		传输层	快递收发负责人	TCP/UDP协议
		网络层	集散中心		IP
		数据链路层				
		物理层	交通工具
